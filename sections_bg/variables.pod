=encoding utf8

=head1 Променливи

Z<variables>
X<variable>

I<Променлива> в Perl е място за съхранение на стойност (L<values>). Макар че и
най-обикновената програма може да обработва стойностите директно, повечето програми
работят с променливи, за да се опрости логиката на кода. Променливите заместват
стойностите. Много по-лесно е да обясним Питагоровата теорема с променливите
C<a>, C<b> и C<c>, отколкото да проверяваме правилността ѝ чрез писането на дълъг
списък с валидни стойности. Тази идея може да изглежда основополагаща. Но
ефективното програмиране изисква от вас умението да балансирате между
общоприложимото и специфичното.

=head2 Обхват на променливите

Z<variable_scopes>

X<variables; scope>
X<scope>
X<builtins; C<package>>

Променливите са видими за части от програмата ви, в зависимост от обхвата си
(L<scope>). Повечето променливи има лексикален обхват (L<lexical_scope>).
I<Файловете> си осигуряват такъв лексикслен обхват, че декларирането на C<пакет>
само по себе си не създава нов обхват:

=begin programlisting

    package Store::Toy;

    my $discount = 0.10;

    package Store::Music;

    # $discount still visible
    say "Our current discount is $discount!";

=end programlisting

X<вградени функции; C<package>; BLOCK>

От версия Perl 5.14 насам можете да подавате блок при деклариране на C<package>.
Този синтаксис I<придава> лексикален обхват:

=begin programlisting

    package Store::Toy
    {
        my $discount = 0.10;
    }

    package Store::Music
    {
        # $discount not available
    }

    package Store::BoardGame;

    # $discount still not available

=end programlisting

=head2 Променливи знаци за тип

Z<sigils>

X<променливи; знаци за тип>
X<знаци за тип>

The sigil of the variable in a declaration determines the type of the variable:
scalar, array, or hash. The sigil used when accessing a variable varies
depending on what you do to the variable. For example, you declare an array as
C<@values>. Access the first element--a single value--of the array with
C<$values[0]>. Access a list of values from the array with C<@values[ @indices
]>.

=head2 Anonymous Variables

X<anonymous variables>
X<variables; anonymous>

Perl variables do not I<require> names. Names exist to help you, the
programmer, keep track of an C<$apple>, C<@barrels>, or C<%cheap_meals>.
Variables created I<without> literal names in your source code are I<anonymous>
variables. The only way to access anonymous variables is by reference
(L<references>).

=head2 Variables, Types, and Coercion

X<variables; types>
X<variables; container type>
X<variables; value type>

A variable in Perl 5 represents both a value (a dollar cost, available pizza
toppings, guitar shops with phone numbers) and the container which stores that
value. Perl's type system deals with I<value types> and I<container types>.
While a variable's I<container type>--scalar, array, or hash--cannot change,
Perl is flexible about a variable's value type. You may store a string in a
variable in one line, append to that variable a number on the next, and
reassign a reference to a function (L<function_references>) on the third.

Performing an operation on a variable which imposes a specific value type may
cause coercion (L<coercion>) from the variable's existing value type.

For example, the documented way to determine the number of entries in an array
is to evaluate that array in scalar context (L<context_philosophy>). Because a
scalar variable can only ever contain a scalar, assigning an array to a scalar
imposes scalar context on the operation, and an array evaluated in scalar
context returns the number of elements in the array:

=begin programlisting

    my $count = @items;

=end programlisting

This relationship between variable types, sigils, and context is essential.
