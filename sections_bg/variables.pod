=encoding utf8

=head1 Променливи

Z<variables>
X<variable>

I<Променлива> в Perl е място за съхранение на стойност (L<values>). Макар че и
най-обикновената програма може да обработва стойностите директно, повечето програми
работят с променливи, за да се опрости логиката на кода. Променливите заместват
стойностите. Много по-лесно е да обясним Питагоровата теорема с променливите
C<a>, C<b> и C<c>, отколкото да проверяваме правилността ѝ чрез писането на дълъг
списък с валидни стойности. Тази идея може да изглежда основополагаща. Но
ефективното програмиране изисква от вас умението да балансирате между
общо приложимото и специфичното.

=head2 Обхват на променливите

Z<variable_scopes>

X<variables; scope>
X<scope>
X<builtins; C<package>>

Променливите са видими за части от програмата ви, в зависимост от обхвата си
(L<scope>). Повечето променливи имат лексикален обхват (L<lexical_scope>).
I<Файловете> осигуряват такъв лексикален обхват. Декларирането на C<package> само по
себе си не създава нов обхват:

=begin programlisting

    package Store::Toy;

    my $discount = 0.10;

    package Store::Music;

    # $discount still visible
    say "Our current discount is $discount!";

=end programlisting

X<вградени функции; C<package>; BLOCK>

От версия Perl 5.14 насам можете да подавате блок при деклариране на C<package>.
Този синтаксис I<създава> лексикален обхват:

=begin programlisting

    package Store::Toy
    {
        my $discount = 0.10;
    }

    package Store::Music
    {
        # $discount not available
    }

    package Store::BoardGame;

    # $discount still not available

=end programlisting

=head2 Променливи знаци за тип

Z<sigils>

X<променливи; знаци за тип>
X<знаци за тип>

Знакът за тип при деклариране на променливата определя нейния тип: скалар, масив или хеш.
Знаците за тип, използвани за извикване на променлива, са различни, в зависимост
от това, което правите с нея. Например, декларирате масив като C<@values>.
Извиквате първия елемент--единична стойност--от масива с C<$values[0]>. Извиквате
списък със стойности от масива с C<@values[ @indices]>.

=head2 Безименни променливи

X<безименни променливи>
X<променливи; безименни>

Променливите в Perl не се I<нуждаят> от имена. Имената съществуват, та вие,
програмистите, да можете да проследите някое C<$apple>, C<@barrels> или
C<%cheap_meals>. Променливите в кода ви, които не са I<изрично> именувани, са
I<безименни> променливи. Единственият начин за извикване на безименни променливи
е чрез референции (L<references>).

=head2 Променливи, Типове и Третиране на данни

X<променливи; типове>
X<променливи; тип на контейнер>
X<променливи; тип на стойност>

Една променлива в Perl 5 се състои от два компонента--стойност(цена в долари,
налични гарнитури за пица, телефонни номера на магазини за китари) и контейнер,
в който се съхранява тази стойност. Системата за типове в Perl работи с
I<типове на стойност> и I<типове на контейнер>. I<Типът контейнер> на една
променлива--скалар, масив или  хеш--не се променя. Perl обаче е гъвкав, що се
отнася до типа стойност на променливите. На един ред може да съхраните низ в
променлива, на следващия ред--да добавите число на същата променлива, а на третия
--да присвоите референция към функция (L<function_references>).

Извършването на операция върху променлива, което налага специфичен тип стойност,
може да доведе до различно третиране на данните (L<coercion>), в зависимост от
действителния тип стойност на променливата.

Например, документираният начин за определяне броя на записите в един масив е
като се представи този масив в скаларен контекст (L<context_philosophy>). Тъй
като скаларните променливи могат да съдържат само скалари, присвояването на
масив към скалар налага скаларен контекст на операцията. Така един масив,
представен в скаларен контекст, връща броя на елементите от масива:

=begin programlisting

    my $count = @items;

=end programlisting

Тези взаимовръзки между типовете променливи, знаците за тип и контекста са от
изключително значение.
