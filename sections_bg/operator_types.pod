=encoding utf8

=head1 Типове оператори

Z<operator_types>

Операторите в Perl указват стойностния контекст, в който аргументите
ще бъдат изпълнени.  За да изберете правилния оператор, трябва да
разберете стойностите на аргументите, които подавате, както и
стойността, която очаквате да получите.

=head2 Числови оператори

Z<numeric_operators>

X<оператори; числов>
X<оператори; аритметичен>
X<оператори; C<+>>
X<C<+>; числов оператор>
X<оператори; C<->>
X<C<->; числов оператор>
X<оператори; C<*>>
X<C<*>; числов оператор>
X<оператори; C</>>
X<C</>; числов оператор>
X<оператори; C<**>>
X<C<**>; числов оператор>
X<оператори; C<%>>
X<C<%>; числов оператор>
X<оператори; C<+=>>
X<C<+=>; числов оператор>
X<оператори; C<-=>>
X<C<-=>; числов оператор>
X<оператори; C<*=>>
X<C<*=>; числов оператор>
X<оператори; C</=>>
X<C</=>; числов оператор>
X<оператори; C<**=>>
X<C<**=>; числов оператор>
X<оператори; C<%=>>
X<C<%=>; числов оператор>
X<оператори; C<-->>
X<C<-->; числов оператор>

Числовите оператори налагат числов контекст върху своите
аргументи. Операторите, които правят това, са стандартните аритметични
оператори като събиране (C<+>); изваждане (C<->); умножение (C<*>);
деление (C</>); повдигане на степен (C<**>); деление по модул (C<%>);
техните варианти, които работят директно върху променливата (C<+=>,
C<-=>, C<*=>, C</=>, C<**=>, и C<%=>); и postfix и prefix автоматично
намаляване на (C<-->).

Операторът за автоматично увеличение има специално поведение, когато
се прилага върху низови стойности (L<auto_increment_operator>).

X<оператори; C<==>>
X<оператори; C<!=>>
X<<< оператори; C<< E<lt> >> >>>
X<<< оператори; C<< E<gt> >> >>>
X<<< оператори; C<< E<lt>= >> >>>
X<<< оператори; C<< E<gt>= >> >>>
X<<< оператори; C<< E<lt>=E<gt> >> >>>

X<C<!=>; оператор за числово сравнение>
X<C<==>; оператор за числово сравнение>
X<<< C<< E<gt> >>; оператор за числово сравнение >>>
X<<< C<< E<lt> >>; оператор за числово сравнение >>>
X<<< C<< E<gt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>=E<gt> >>; оператор за числово сравнение >>>

Някои оператора за сравнение налагат числов контекст върху своите
аргументи. Това са оператора за числово равенство (C<==>); за числово
неравенство (C<!=>); по-голямо (C<< E<gt> >>); по-малко (C<< E<lt>
>>); по-голямо или равно (C<< E<gt>= >>); по-малко или равно (C<<
E<lt>= >>); и  сортиращият оператор за сравнение (C<< E<lt>=E<gt>
>>()).

=head2 Оператори за работа с низове

X<оператори; низ>
X<низове; оператори>
X<оператори; C<=~>>
X<C<=~>; низов оператор>
X<оператори; C<!~>>
X<C<!~>; низов оператор>
X<оператори; C<.>>
X<C<.>; низов оператор>

Операторите за низове налагат низов контекст върху своите
аргументи. Операторите за положително и отрицателно търсене в низ,
чрез регулярен израз, (C<=~> и C<!~>), както и оператора за конкатация
(C<.>) работят с низове.

X<оператори; C<eq>>
X<оператори; C<ne>>
X<оператори; C<gt>>
X<оператори; C<lt>>
X<оператори; C<ge>>
X<оператори; C<le>>
X<оператори; C<cmp>>
X<C<eq>; оператор за сравняване на низове>
X<C<ne>; оператор за сравняване на низове>
X<C<gt>; оператор за сравняване на низове>
X<C<lt>; оператор за сравняване на низове>
X<C<ge>; оператор за сравняване на низове>
X<C<le>; оператор за сравняване на низове>
X<C<cmp>; оператор за сравняване на низове>

Оператори за сравнение на низове налагат низов контекст върху своите
аргументи. Това са операторизе за равенство между низове (C<eq>);
неравенство между низове (C<ne>); по-голямо (C<gt>); по-малко (C<lt>);
по-голямо или равно (C<ge>); по-малко или равно (C<le>); и сортиращият
низов оператор за сравнение (C<cmp>).

=head2 Логически оператори

X<оператори; логически>
X<оператори; C<&&>>
X<оператори; C<and>>
X<оператори; C<||>>
X<оператори; C<or>>
X<оператори; C<//>>
X<оператори; C<?:>>
X<оператори; C<!>>
X<оператори; C<not>>
X<оператори; C<xor>>
X<C<&&>; логически оператор>
X<C<and>; логически оператор>
X<C<||>; логически оператор>
X<C<or>; логически оператор>
X<C<//>; логически оператор>
X<C<?:>; логически оператор>
X<C<!>; логически оператор>
X<C<not>; логически оператор>
X<C<xor>; логически оператор>
X<оператори; defined-or>
X<defined-or; логически оператор>
X<short-circuiting; ранно прекъсване>

Логическите оператори налагат булев контекст върху своите
аргументи. Логически оператори са C<&&>, C<and>, C<||>, и
C<or>. Всичките се използват в infix позиция и също така всичките
I<прекъсват възможно най-ранно> (L<short_circuiting>). Операторите
думи имат по-нисък приоритет от другата им форма, която се пише чрез
пунктуационни знаци.

Операторът defined-or, C<//>, тества дали аргумента му е I<дефиниран>. Съвсем различно от операторът C<||>, който тества I<истинностната> стойност на аргументите си, операторът C<//> връща истинностна стойност истина дори когато аргумента му има числова стойност нула или е празен низ. Това е лесен метод за писане на забавен код, който задава стойност по подразбиране на променливи:

=begin programlisting

    sub name_pet
    {
        my $name = shift // 'Шаро';
        ...
    }

=end programlisting

X<C<?:>; условен оператор>

Условния оператор (C<?:>) работи с три аргумента. Първият от
аргументите се изпълнява в булев контекст и ако той е истина, връща
резултата от втория аргумент, иначе връща резултата от третия
аргумент:

=begin programlisting

    my $truthiness = $value ? 'истина' : 'неистина';

=end programlisting

Префиксните оператори C<!> и C<not> връщат истина, ако аргумента им
има булева стойност неистина и връщат неистина, ако аргумента им има
булева стойност истина. Операторът C<not> е с по-нисък приоритет от
C<!>.

Операторът C<xor> е инфикс оператор, който връща резултата от
прилагането на изключващо „или“ към аргументите си.

=head2 Побитови оператори

X<operators; bitwise>
X<<< operators; C<< E<lt>E<lt> >> >>>
X<<< operators; C<< E<gt>E<gt> >> >>>
X<operators; C<&>>
X<operators; C<|>>
X<operators; C<^>>
X<operators; C<&=>>
X<operators; C<|=>>
X<operators; C<^=>>
X<<< operators; C<< E<lt>E<lt>= >> >>>
X<<< operators; C<< E<gt>E<gt>= >> >>>

X<<< C<< E<lt>E<lt> >>; bitwise operator >>>
X<<< C<< E<gt>E<gt> >>; bitwise operator >>>

X<C<&>; bitwise operator>
X<C<|>; bitwise operator>
X<C<^>; bitwise operator>
X<C<&=>; bitwise operator>
X<C<|=>; bitwise operator>
X<C<^=>; bitwise operator>
X<<< C<< E<lt>E<lt>= >>; bitwise operator >>>
X<<< C<< E<gt>E<gt>= >>; bitwise operator >>>

Bitwise operators treat their operands numerically at the bit level. These
operations are uncommon. They consist of left shift (C<< << >>), right shift
(C<< >> >>), bitwise and (C<&>), bitwise or (C<|>), and bitwise xor (C<^>), as
well as their in-place variants (C<< <<= >>, C<< >>= >>, C<&=>, C<|=>, and
C<^=>).

=head2 Special Operators

Z<auto_increment_operator>

X<operators; auto-increment>
X<auto-increment>
X<operators; C<++>>
X<C<++>; auto-increment operator>

The auto-increment operator has special behavior. When used on a value with a
numeric component (L<cached_coercions>), the operator increments that numeric
component. If the value is obviously a string (and has no numeric component),
the operator increments that string value such that C<a> becomes C<b>, C<zz>
becomes C<aaa>, and C<a9> becomes C<b0>.

=begin programlisting

    my $num = 1;
    my $str = 'a';

    $num++;
    $str++;
    is( $num,   2, 'numeric autoincrement' );
    is( $str, 'b', 'string autoincrement'  );

    no warnings 'numeric';
    $num += $str;
    $str++;

    is( $num, 2, 'numeric addition with $str'    );
    is( $str, 1, '... gives $str a numeric part' );

=end programlisting

X<operators; repetition>
X<operators; C<x>>
X<C<x>; repetition operator>

The repetition operator (C<x>) is an infix operator with complex behavior. In
list context, when given a list, it evaluates to that list repeated the number
of times specified by its second operand. In list context when given a scalar,
it produces a string consisting of the string value of its first operand
concatenated to itself the number of times specified by its second operand.

In scalar context, the operator always produces a concatenated string repeated
appropriately. For example:

=begin programlisting

    my @scheherazade = ('nights') x 1001;
    my $calendar     =  'nights'  x 1001;
    my $cal_length   =  length $calendar;

    is( @scheherazade, 1001, 'list repeated' );
    is( $cal_length,   1001 * length 'nights',
                       'word repeated' );

    my @schenolist   =  'nights'  x 1001;
    my $calscalar    = ('nights') x 1001;

    is( @schenolist, 1, 'no lvalue list' );
    is( length $calscalar,
        1001 * length 'nights', 'word still repeated' );

=end programlisting

X<operators; range>
X<range>
X<operators; C<..>>
X<C<..>; range operator>

The infix I<range> operator (C<..>) produces a list of items in list context:

=begin programlisting

    my @cards = ( 2 .. 10, 'J', 'Q', 'K', 'A' );

=end programlisting

It can produce simple, incrementing ranges (both as integers or strings), but
it cannot intuit patterns or more complex ranges.

X<operators; flip-flop>
X<flip-flop>
X<C<..>; flip-flop operator>

In boolean context, the range operator becomes the I<flip-flop> operator. This
operator produces a false value until its left operand is true. That value
stays true until the right operand is true, after which the value is false
again until the left operand is true again. Imagine parsing the text of a
formal letter with:

=begin programlisting

    while (/Hello, $user/ .. /Sincerely,/)
    {
        say "> $_";
    }

=end programlisting

X<operators; comma>
X<operators; C<,>>
X<C<,>; operator>
X<<< operators; C<< =E<gt> >> >>>
X<<< C<< =E<gt> >>; fat comma operator >>>

The I<comma> operator (C<,>) is an infix operator. In scalar context it
evaluates its left operand then returns the value produced by evaluating its
right operand. In list context, it evaluates both operands in left-to-right
order.

The fat comma operator (C<< => >>) also automatically quotes any bareword used
as its left operand (L<hashes>).
