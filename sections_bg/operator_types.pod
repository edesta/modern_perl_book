=encoding utf8

=head1 Типове оператори

Z<operator_types>

Операторите в Perl указват стойностния контекст, в който аргументите
ще бъдат изпълнени.  За да изберете правилния оператор, трябва да
разберете стойностите на аргументите, които подавате, както и
стойността, която очаквате да получите.

=head2 Числови оператори

Z<numeric_operators>

X<оператори; числов>
X<оператори; аритметичен>
X<оператори; C<+>>
X<C<+>; числов оператор>
X<оператори; C<->>
X<C<->; числов оператор>
X<оператори; C<*>>
X<C<*>; числов оператор>
X<оператори; C</>>
X<C</>; числов оператор>
X<оператори; C<**>>
X<C<**>; числов оператор>
X<оператори; C<%>>
X<C<%>; числов оператор>
X<оператори; C<+=>>
X<C<+=>; числов оператор>
X<оператори; C<-=>>
X<C<-=>; числов оператор>
X<оператори; C<*=>>
X<C<*=>; числов оператор>
X<оператори; C</=>>
X<C</=>; числов оператор>
X<оператори; C<**=>>
X<C<**=>; числов оператор>
X<оператори; C<%=>>
X<C<%=>; числов оператор>
X<оператори; C<-->>
X<C<-->; числов оператор>

Числовите оператори налагат числов контекст върху своите
аргументи. Операторите, които правят това, са стандартните аритметични
оператори като събиране (C<+>); изваждане (C<->); умножение (C<*>);
деление (C</>); повдигане на степен (C<**>); деление по модул (C<%>);
техните варианти, които работят директно върху променливата (C<+=>,
C<-=>, C<*=>, C</=>, C<**=>, и C<%=>); и postfix и prefix автоматично
намаляване на (C<-->).

Операторът за автоматично увеличение има специално поведение, когато
се прилага върху низови стойности (L<auto_increment_operator>).

X<оператори; C<==>>
X<оператори; C<!=>>
X<<< оператори; C<< E<lt> >> >>>
X<<< оператори; C<< E<gt> >> >>>
X<<< оператори; C<< E<lt>= >> >>>
X<<< оператори; C<< E<gt>= >> >>>
X<<< оператори; C<< E<lt>=E<gt> >> >>>

X<C<!=>; оператор за числово сравнение>
X<C<==>; оператор за числово сравнение>
X<<< C<< E<gt> >>; оператор за числово сравнение >>>
X<<< C<< E<lt> >>; оператор за числово сравнение >>>
X<<< C<< E<gt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>= >>; оператор за числово сравнение >>>
X<<< C<< E<lt>=E<gt> >>; оператор за числово сравнение >>>

Някои оператора за сравнение налагат числов контекст върху своите
аргументи. Това са оператора за числово равенство (C<==>); за числово
неравенство (C<!=>); по-голямо (C<< E<gt> >>); по-малко (C<< E<lt>
>>); по-голямо или равно (C<< E<gt>= >>); по-малко или равно (C<<
E<lt>= >>); и  сортиращият оператор за сравнение (C<< E<lt>=E<gt>
>>()).

=head2 Оператори за работа с низове

X<оператори; низ>
X<низове; оператори>
X<оператори; C<=~>>
X<C<=~>; низов оператор>
X<оператори; C<!~>>
X<C<!~>; низов оператор>
X<оператори; C<.>>
X<C<.>; низов оператор>

Операторите за низове налагат низов контекст върху своите
аргументи. Операторите за положително и отрицателно търсене в низ,
чрез регулярен израз, (C<=~> и C<!~>), както и оператора за конкатация
(C<.>) работят с низове.

X<оператори; C<eq>>
X<оператори; C<ne>>
X<оператори; C<gt>>
X<оператори; C<lt>>
X<оператори; C<ge>>
X<оператори; C<le>>
X<оператори; C<cmp>>
X<C<eq>; оператор за сравняване на низове>
X<C<ne>; оператор за сравняване на низове>
X<C<gt>; оператор за сравняване на низове>
X<C<lt>; оператор за сравняване на низове>
X<C<ge>; оператор за сравняване на низове>
X<C<le>; оператор за сравняване на низове>
X<C<cmp>; оператор за сравняване на низове>

Оператори за сравнение на низове налагат низов контекст върху своите
аргументи. Това са операторизе за равенство между низове (C<eq>);
неравенство между низове (C<ne>); по-голямо (C<gt>); по-малко (C<lt>);
по-голямо или равно (C<ge>); по-малко или равно (C<le>); и сортиращият
низов оператор за сравнение (C<cmp>).

=head2 Логически оператори

X<оператори; логически>
X<оператори; C<&&>>
X<оператори; C<and>>
X<оператори; C<||>>
X<оператори; C<or>>
X<оператори; C<//>>
X<оператори; C<?:>>
X<оператори; C<!>>
X<оператори; C<not>>
X<оператори; C<xor>>
X<C<&&>; логически оператор>
X<C<and>; логически оператор>
X<C<||>; логически оператор>
X<C<or>; логически оператор>
X<C<//>; логически оператор>
X<C<?:>; логически оператор>
X<C<!>; логически оператор>
X<C<not>; логически оператор>
X<C<xor>; логически оператор>
X<оператори; defined-or>
X<defined-or; логически оператор>
X<short-circuiting; ранно прекъсване>

Логическите оператори налагат булев контекст върху своите
аргументи. Логически оператори са C<&&>, C<and>, C<||>, и
C<or>. Всичките се използват в infix позиция и също така всичките
I<прекъсват възможно най-ранно> (L<short_circuiting>). Операторите
думи имат по-нисък приоритет от другата им форма, която се пише чрез
пунктуационни знаци.

Операторът defined-or, C<//>, тества дали аргумента му е I<дефиниран>. Съвсем различно от операторът C<||>, който тества I<истинностната> стойност на аргументите си, операторът C<//> връща истинностна стойност истина дори когато аргумента му има числова стойност нула или е празен низ. Това е лесен метод за писане на забавен код, който задава стойност по подразбиране на променливи:

=begin programlisting

    sub name_pet
    {
        my $name = shift // 'Шаро';
        ...
    }

=end programlisting

X<C<?:>; условен оператор>

Условния оператор (C<?:>) работи с три аргумента. Първият от
аргументите се изпълнява в булев контекст и ако той е истина, връща
резултата от втория аргумент, иначе връща резултата от третия
аргумент:

=begin programlisting

    my $truthiness = $value ? 'истина' : 'неистина';

=end programlisting

Префиксните оператори C<!> и C<not> връщат истина, ако аргумента им
има булева стойност неистина и връщат неистина, ако аргумента им има
булева стойност истина. Операторът C<not> е с по-нисък приоритет от
C<!>.

Операторът C<xor> е инфикс оператор, който връща резултата от
прилагането на изключващо „или“ към аргументите си.

=head2 Побитови оператори

X<оператори; побитово>
X<<< оператори; C<< E<lt>E<lt> >> >>>
X<<< оператори; C<< E<gt>E<gt> >> >>>
X<оператори; C<&>>
X<оператори; C<|>>
X<оператори; C<^>>
X<оператори; C<&=>>
X<оператори; C<|=>>
X<оператори; C<^=>>
X<<< оператори; C<< E<lt>E<lt>= >> >>>
X<<< оператори; C<< E<gt>E<gt>= >> >>>

X<<< C<< E<lt>E<lt> >>; побитови оператори >>>
X<<< C<< E<gt>E<gt> >>; побитови оператори >>>

X<C<&>; побитови оператори>
X<C<|>; побитови оператори>
X<C<^>; побитови оператори>
X<C<&=>; побитови оператори>
X<C<|=>; побитови оператори>
X<C<^=>; побитови оператори>
X<<< C<< E<lt>E<lt>= >>; побитови оператори >>>
X<<< C<< E<gt>E<gt>= >>; побитови оператори >>>

Побитовите оператори работят върху нулите и единиците, с които
вътрешно са представени техните аргументи. Тяхното използване не се
среща често. Побитови оператори са операторът за изместване наляво
(C<< << >>); операторът за изместване надясно (C<< >> >>); побитово
„и“ (C<&>); побитово „или“ (C<|>); и побитово изключващо „или“
(C<^>). Вариантите, които работят директно върху променливата, са C<<
<<= >>, C<< >>= >>, C<&=>, C<|=>, и C<^=>.

=head2 Специални оператори

Z<auto_increment_operator>

X<оператори; автоматично увеличаване>
X<автоматично увеличаване>
X<оператори; C<++>>
X<C<++>; оператор за автоматично увеличаване>

Операторът за автоматично увеличаване има особено поведение. Когато се
използва върху стойност с числов компонент(има нещо, което прилича на
число в началото на низа, ако стойността е низ) (L<cached_coercions>),
операторът ще третира стойността като число и ще увеличи това число с
1. Ако стойността не е число, а низ без числов компонент в началото,
то операторът увеличава стойността на низа, така че C<a> става C<b>,
C<zz> става C<aaa>, а C<a9> става C<b0>.

=begin programlisting

    my $num = 1;
    my $str = 'a';

    $num++;
    $str++;
    is( $num,   2, 'числово увеличаване' );
    is( $str, 'b', 'низово увеличаване'  );

    no warnings 'numeric';
    $num += $str;
    $str++;

    is( $num, 2, 'числово събиране с $str'    );
    is( $str, 1, '... интерпретира $str като число' );

=end programlisting

X<оператори; повторение>
X<оператори; C<x>>
X<C<x>; оператор за повторение>

The repetition operator (C<x>) is an infix operator with complex behavior. In
list context, when given a list, it evaluates to that list repeated the number
of times specified by its second operand. In list context when given a scalar,
it produces a string consisting of the string value of its first operand
concatenated to itself the number of times specified by its second operand.

In scalar context, the operator always produces a concatenated string repeated
appropriately. For example:

=begin programlisting

    my @scheherazade = ('nights') x 1001;
    my $calendar     =  'nights'  x 1001;
    my $cal_length   =  length $calendar;

    is( @scheherazade, 1001, 'list repeated' );
    is( $cal_length,   1001 * length 'nights',
                       'word repeated' );

    my @schenolist   =  'nights'  x 1001;
    my $calscalar    = ('nights') x 1001;

    is( @schenolist, 1, 'no lvalue list' );
    is( length $calscalar,
        1001 * length 'nights', 'word still repeated' );

=end programlisting

X<operators; range>
X<range>
X<operators; C<..>>
X<C<..>; range operator>

The infix I<range> operator (C<..>) produces a list of items in list context:

=begin programlisting

    my @cards = ( 2 .. 10, 'J', 'Q', 'K', 'A' );

=end programlisting

It can produce simple, incrementing ranges (both as integers or strings), but
it cannot intuit patterns or more complex ranges.

X<operators; flip-flop>
X<flip-flop>
X<C<..>; flip-flop operator>

In boolean context, the range operator becomes the I<flip-flop> operator. This
operator produces a false value until its left operand is true. That value
stays true until the right operand is true, after which the value is false
again until the left operand is true again. Imagine parsing the text of a
formal letter with:

=begin programlisting

    while (/Hello, $user/ .. /Sincerely,/)
    {
        say "> $_";
    }

=end programlisting

X<operators; comma>
X<operators; C<,>>
X<C<,>; operator>
X<<< operators; C<< =E<gt> >> >>>
X<<< C<< =E<gt> >>; fat comma operator >>>

The I<comma> operator (C<,>) is an infix operator. In scalar context it
evaluates its left operand then returns the value produced by evaluating its
right operand. In list context, it evaluates both operands in left-to-right
order.

The fat comma operator (C<< => >>) also automatically quotes any bareword used
as its left operand (L<hashes>).
