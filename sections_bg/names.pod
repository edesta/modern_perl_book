=encoding utf8

=head1 Имена

Z<names>

X<имена>
X<идентификатори>

I<Имената> (или I<идентификаторите>) са навсякъде в Perl програмите: променливи,
функции, пакети, класове, дори файлови манипулатори. Всички тези имена започват
с буква или долна черта. След това е допустима произволна комбинация от букви,
цифри и долни черти. Когато е в сила правилото за C<utf8>N<"Прагмите" като C<utf8>
включват правила, които парсърът и компилаторът спазват. (бел. прев.)> в изходния
код (L<unicode>), можете да използвате всеки буквено-числов символ от UTF-8 в
идентификаторите.
Ето някои валидни идентификатори в Perl:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # use utf8; разрешава използването на уникод
    package Ingy::DE<ouml>t::Net;

=end programlisting

А тези идентификатори са невалидни в Perl:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<намиране на символи>

I<Имената съществуват най-вече за удобство на програмиста>. Това важи само
за буквени имена, каквито се срещат във вашия изходен код, като C<sub
fetch_pie> или C<my $waffleiron>. Но единствено парсърът на Perl може да прилага
правилата за имена на идентификаторите.

Динамичният характер на Perl ви позволява да ползвате имена,
генерирани по време на изпълнение, или взети от входа на програмата.
Този метод за I<намиране на символи> предоставя гъвкавост, донякъде за сметка на
сигурността.
По-специално, непрякото извикване на функции или методи или търсенето на символи
в пространство от имена ви дава възможност да заобиколите парсъра на Perl.

Такава практика може да доведе до доста объркващ код. Както Марк Джейсън Доминус
препоръчва много удачноN<U<http://perl.plover.com/varvarname.html>>, ползвайте хеш
(L<hashes>) или сложни структури от данни (L<nested_data_structures>).

=head2 Имена на променливи и Знаци за тип

X<променливи; имена>
X<скаларни променливи>
X<променливи; скалари>
X<скалари>
X<масиви>
X<променливи; скалари>
X<хешове>
X<променливи; хешове>
X<знак за тип>

I<Имената на променливите> винаги започват със I<знак за тип> (или символ), указващ
типа стойност на променливата. I<Скаларните променливи> (L<scalars>) използват
знака за долар (C<$>). I<Масивите> (L<arrays>) се обозначават с маймунка (C<@>).
Пред I<хешовете> (L<hashes>) се слага знак за процент (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Тези знаци предоставят видимо пространство от имена за променливите. Така е
възможно--макар и объркващо--да се декларират множество променливи с еднакво име
и от различни типове:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Perl ще разчете правилно тези инструкции, но същото не важи и за хората,
които ще видят този код.

X<променящ се знак за тип>

Знаците за тип в Perl 5 са I<променящи се знаци за тип>. Контекстът определя
количеството елементи или типа данни, които ще получите. А от знака за тип
зависи какво ще направите с данните от променливи. Например, за да достъпите
даден елемент от масив или хеш, трябва да ползвате знака за скалар (C<$>):

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

Паралелът със значението на контекста е важен. Използването на скаларен елемент
от съвкупност от данни като I<lvalue> (обектът на присвояване, вляво от знака C<=>),
прилага скаларен контекст (L<context_philosophy>) на I<rvalue>
(присвоената стойност, вдясно от знака C<=>).

X<отрязъци>

Съответно, при достъпването на множество елементи от хеш или масив--наричано още
I<отрязване>--се използва символът маймунка (C<@>), който прилага списъчен
контекстN<...дори ако самият списък съдържа нула или един елемент>:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

Най-сигурният начин да се определи типа на една променлива--скалар, масив или
хеш--е като се види какви операции се изпълняват с нея. Скаларите поддържат всички
основни операции--низови, числови и булеви. Масивите осъществяват индексиран достъп
посредством квадратни скоби. А хешовете имат достъп с ключ чрез фигурни скоби.

=head2 Пространства от имена

X<пълно име>
X<пространства от имена>

Perl предоставя механизъм за групиране на сходни функции и променливи в техни
собствени именовани пространства--I<пространства от имена> (L<packages>).
Пространство от имена е именован набор от символи. В Perl са разрешени
йерархични пространства от имена. В тях имената са съединени с две двоеточия
(C<::>), където C<DessertShop::IceCream> се отнася за логически набор от
свързани променливи и функции (като C<scoop()> и C<pour_hot_fudge()>).

Когато се намирате вътре в едно пространство от имена, може да използвате
съкратено име за неговите членове.
Извън пространството от имена посочвате негов член само с I<пълното му име>.
Например, в пространството на C<DessertShop::IceCream>, C<add_sprinkles()> е същата функция,
както C<DessertShop::IceCream::add_sprinkles()> извън това пространство.

По конвенция, дефинираните от потребителя имена на пакети започват с главна
буква. Имената с малки букви са запазени  за прагми от стандартната дистрибуция
на Perl (ядрото). Такива са C<strict> и C<warnings>, например.
Тази политика е наложена най-вече от общоприетите принципи на общността.


Всички пространства от имена в Perl 5 са видими глобално. Когато Perl търси
символ в C<DessertShop::IceCream::Freezer>, той гледа в C<main::> таблицата със
символи за символа, представляващ пространството от имена C<DessertShop::>.
После гледа в него за пространството C<IceCream::>, и т.н. Пространството
C<Freezer::> е видимо и извън пространството C<IceCream::>. Влагането на едно в
друго пространство е просто начин на съхраняване и не предполага никакви
зависимости от тип наследник-родител на едното от другото. Нито пък предполага
някакви зависимости между съседните пакети намиращи се в едно и също
пространство. Единствено програмистът създава логическата връзка между тях,
като избира подходящи имена и ги организира добре.
